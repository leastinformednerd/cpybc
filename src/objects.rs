use std::ops::Index;

#[derive(Debug, PartialEq)]
pub struct PyObjectRegion(pub(crate) Vec<PyObject>);

impl PyObjectRegion {
    fn get(&self, index: PyObjectIndex) -> Option<&PyObject> {
        self.0.get(index.0)
    }
}

impl Index<PyObjectIndex> for PyObjectRegion {
    type Output = PyObject;

    fn index(&self, index: PyObjectIndex) -> &Self::Output {
        &self.0[index.0]
    }
}

#[derive(Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Clone, Copy)]
pub struct PyObjectIndex(pub usize);

#[derive(Debug, PartialEq)]
pub enum PyObject {
    Null,
    None,
    Bool(bool),
    StopIter,
    Ellipsis,
    SmallInt(i64),
    LargeInt(PyLargeInt),
    Float(f64),
    Complex(f64, f64),
    Bytes(Box<[u8]>),
    String(Box<str>),
    Tuple(Box<[PyObjectIndex]>),
    List(Box<[PyObjectIndex]>),
    Dict(Box<[(PyObjectIndex, PyObjectIndex)]>),
    Set(Box<[PyObjectIndex]>),
    FrozenSet(Box<[PyObjectIndex]>),
    Code(CodeObjectConstructor),
}
type PyLargeInt = Box<[u8]>;

impl PyObject {
    fn is_bytes(&self) -> bool {
        if let PyObject::Bytes(_) = self {
            true
        } else {
            false
        }
    }
}

#[derive(Debug, PartialEq)]
pub struct CodeObjectConstructor {
    pub(crate) arg_count: i32,
    pub(crate) pos_only_arg_count: i32,
    pub(crate) kw_only_arg_count: i32,
    pub(crate) stack_size: i32,
    pub(crate) flags: i32,
    pub(crate) code: PyObjectIndex,
    pub(crate) consts: PyObjectIndex,
    pub(crate) names: PyObjectIndex,
    // This is a tuple of local variable + free variable names
    pub(crate) locals_plus_names: PyObjectIndex,
    // This is a list that corresponds to flags for
    pub(crate) locals_plus_kinds: PyObjectIndex,
    pub(crate) filename: PyObjectIndex,
    pub(crate) name: PyObjectIndex,
    pub(crate) qualified_name: PyObjectIndex,
    pub(crate) first_line_no: i32,
    pub(crate) line_table: PyObjectIndex,
    pub(crate) exception_table: PyObjectIndex,
}

/// Wrapper around a `CodeObjectConstructor` that acts as "proof" that the code
/// object that it represents is valid (in that all the fields are the correct
/// type and trivial length checks pass). Things like validating that the code
/// will not attempt an out of bound access, or pop from an empty stack, are not
/// in scope
#[derive(Debug, PartialEq)]
pub struct CodeObject(CodeObjectConstructor);

#[derive(Debug, PartialEq)]
pub struct CodeObjectFlags(i32);

impl CodeObjectFlags {
    /// Returns true if this is a valid set of code object flags
    fn validate(_raw: i32) -> bool {
        todo!()
    }
}

#[derive(Debug, PartialEq)]
pub enum CodeObjectConstructionError<'a> {
    /// An out of bounds PyObjectIndex was provided for this region. This
    /// shouldn't be possible if the CodeObjectConstructor was generated by this
    /// library, however errors can happen, and if there are multiple regions then
    /// attempting to call `CodeObjectConstructor::construct` with a different
    /// region than it was made with is an error, and may cause this
    OutOfBoundsIndex(PyObjectIndex),
    /// Expected the bytecode string to be bytes, actual is noted
    ExpectedCodeBytes(&'a PyObject),
    /// Expected the locals_plus_names field to be a tuple of strings, actual
    /// is noted (with the caveat that due to the way that sequences are
    /// represented, the type of any children will not be immediately apparent
    ExpectedLocalsTupleOfStrings(&'a PyObject),
    /// Expected the locals_plus_kinds to be bytes, actual is noted
    ExpectedLocalsBytes(&'a PyObject),
    /// Expected locals_plus_names and locals_plus_kinds to have equal length,
    /// their actual lengths are noted
    LocalsSizeMismatch { names_len: usize, kinds_len: usize },
    /// Expected that all signed int length fields are positive, and that there
    /// are not more more pos only / kw only args than args, and that there are
    /// less args than total locals
    ///
    /// This is a really weak check, and it's possible to do better, but I have
    /// not yet done so
    ArgCountMismatch {
        arg_count: i32,
        pos_only_arg_count: i32,
        kw_only_arg_count: i32,
        locals_len: usize,
    },
    /// Expected names to be a tuple, actual is noted, same caveats apply as to
    /// the equivalent for locals in terms of children
    ExpectedNamesTupleOfStrings(&'a PyObject),
    /// Expected consts to be a tuple, actual is noted
    ExpectedConstsTuple(&'a PyObject),
    /// Expected filename to be a string, actual is noted
    ExpectedFileNameString(&'a PyObject),
    /// Expected qualified name to be a string, actual is noted
    ExpectedQualifiedNameString(&'a PyObject),
    /// Expected name to be a subtstring of the qualified name, actual is noted
    // I am not entirely sure that this actually true of all names / qualnames
    // that are created by CPython, but I can't imagine where it wouldn't be
    // valid, and I'll relax the requirement if it comes up
    ExpectedNameSubstringQualifiedName(&'a PyObject),
    /// Expected first line number to be greater than 0, actual is noted
    ExpectedLineNoGtZero(i32),
    /// Expected the line table to be bytes, actual is noted
    ExpectedLineTableBytes(&'a PyObject),
    /// Expected the exception table to be bytes, actual is noted
    ExpectedExceptionTableBytes(&'a PyObject),
    /// Expected stack size to be at least 0, actual is noted
    ExpectedStackSize(i32),
    /// Flags are invalid / inconsistent
    InvalidFlags(i32),
}

impl CodeObjectConstructor {
    /// Consume self and try to create a valid `CodeObject` that wraps this and
    /// provides an interface for getting computed properties
    pub fn construct(
        self,
        region: &PyObjectRegion,
    ) -> Result<CodeObject, CodeObjectConstructionError<'_>> {
        use CodeObjectConstructionError as CE;
        let Some(code) = region.get(self.code) else {
            return Err(CE::OutOfBoundsIndex(self.code));
        };
        if !code.is_bytes() {
            return Err(CE::ExpectedCodeBytes(code));
        }

        let (locals_plus_names_obj, locals_plus_names) = match region.get(self.locals_plus_names) {
            None => return Err(CE::OutOfBoundsIndex(self.locals_plus_names)),
            Some(b @ PyObject::Tuple(inner)) => (b, inner),
            Some(obj) => return Err(CE::ExpectedLocalsTupleOfStrings(obj)),
        };
        if !locals_plus_names.iter().all(|idx| {
            if let Some(PyObject::String(_)) = region.get(*idx) {
                true
            } else {
                false
            }
        }) {
            return Err(CE::ExpectedLocalsTupleOfStrings(locals_plus_names_obj));
        }
        let locals_plus_kinds = match region.get(self.locals_plus_kinds) {
            None => return Err(CE::OutOfBoundsIndex(self.locals_plus_kinds)),
            Some(PyObject::Bytes(b)) => b,
            Some(obj) => return Err(CE::ExpectedLocalsBytes(obj)),
        };
        if locals_plus_kinds.len() != locals_plus_names.len() {
            return Err(CE::LocalsSizeMismatch {
                names_len: locals_plus_names.len(),
                kinds_len: locals_plus_kinds.len(),
            });
        }

        // TODO: Actually count the number of args types and verify that matches the claimed
        if self.arg_count < 0
            || self.pos_only_arg_count < 0
            || self.kw_only_arg_count < 0
            || self.arg_count as usize > locals_plus_names.len()
            || self.pos_only_arg_count + self.kw_only_arg_count > self.arg_count
        {
            return Err(CE::ArgCountMismatch {
                arg_count: self.arg_count,
                pos_only_arg_count: self.pos_only_arg_count,
                kw_only_arg_count: self.kw_only_arg_count,
                locals_len: locals_plus_names.len(),
            });
        }

        let (names_obj, names) = match region.get(self.names) {
            None => return Err(CE::OutOfBoundsIndex(self.names)),
            Some(b @ PyObject::Tuple(inner)) => (b, inner),
            Some(obj) => return Err(CE::ExpectedNamesTupleOfStrings(obj)),
        };
        if !names.iter().all(|idx| {
            if let Some(PyObject::String(_)) = region.get(*idx) {
                true
            } else {
                false
            }
        }) {
            return Err(CE::ExpectedNamesTupleOfStrings(names_obj));
        }

        match region.get(self.consts) {
            None => return Err(CE::OutOfBoundsIndex(self.consts)),
            Some(PyObject::Tuple(_)) => (),
            Some(found) => return Err(CE::ExpectedConstsTuple(found)),
        }

        match region.get(self.filename) {
            None => return Err(CE::OutOfBoundsIndex(self.filename)),
            Some(PyObject::String(_)) => (),
            Some(found) => return Err(CE::ExpectedFileNameString(found)),
        }

        let qualified_name = match region.get(self.qualified_name) {
            None => return Err(CE::OutOfBoundsIndex(self.name)),
            Some(PyObject::String(s)) => s.as_ref(),
            Some(found) => return Err(CE::ExpectedQualifiedNameString(found)),
        };

        match region.get(self.qualified_name) {
            None => return Err(CE::OutOfBoundsIndex(self.qualified_name)),
            Some(PyObject::String(name)) if qualified_name.find(name.as_ref()).is_some() => (),
            Some(found) => return Err(CE::ExpectedNameSubstringQualifiedName(found)),
        }

        if self.first_line_no < 1 {
            return Err(CE::ExpectedLineNoGtZero(self.first_line_no));
        }

        // TODO: Validate that this is a valid line table, and that it covers
        // the entire bytecode object
        match region.get(self.line_table) {
            None => return Err(CE::OutOfBoundsIndex(self.line_table)),
            Some(PyObject::Bytes(_)) => (),
            Some(found) => return Err(CE::ExpectedLineTableBytes(found)),
        }

        // TODO: Validate that this is a valid exception table, and that it
        // covers the entire bytecode object
        match region.get(self.exception_table) {
            None => return Err(CE::OutOfBoundsIndex(self.exception_table)),
            Some(PyObject::Bytes(_)) => (),
            Some(found) => return Err(CE::ExpectedExceptionTableBytes(found)),
        }

        if self.stack_size < 0 {
            return Err(CE::ExpectedStackSize(self.stack_size));
        }

        if !CodeObjectFlags::validate(self.flags) {
            return Err(CE::InvalidFlags(self.flags));
        }

        Ok(CodeObject(self))
    }
}
